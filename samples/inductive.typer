% build a declaration
% var-name = value-expr;
make-decl : Sexp -> Sexp -> Sexp;
make-decl var-name value-expr =
  node_ (symbol_ "_=_")
    (cons (a := Sexp) var-name
      (cons (a := Sexp) value-expr (nil (a := Sexp))));

% build inductive-cons
% ctor-name = inductive-cons type-name ctor-name;
make-cons : Sexp -> Sexp -> Sexp;
make-cons ctor-name type-name =
  make-decl ctor-name
    (node_ (symbol_ "inductive-cons")
      (cons (a := Sexp) type-name
        (cons (a := Sexp) ctor-name (nil (a := Sexp)))));

% buil type annotation
% var-name : type-expr;
make-ann : Sexp -> Sexp -> Sexp;
make-ann var-name type-expr =
  node_ (symbol_ "_:_")
    (cons (a := Sexp) var-name
      (cons (a := Sexp) type-expr (nil (a := Sexp))));


type-impl = lambda (x : List Sexp) ->
  % x follow the mask -> (_|_ Nat zero (succ Nat))
  %               Type name  --^    ^------^ constructors

  % Get expression
  let expr = head (a := Sexp) x in
  let sexp_nil = (nil (a := Sexp)) in

  % Expression is  node_ (symbol_ "|") (list)
  % we only care about the list bit

  let get-list = (lambda (node : Sexp) ->
    sexp_dispatch_ (a := List Sexp) node
      (lambda (op : Sexp) -> (lambda (lst : List Sexp) -> lst)) % Nodes
      (lambda (str : String)    -> sexp_nil)           % Symbol
      (lambda (str : String)    -> sexp_nil)           % String
      (lambda (int : Int)       -> sexp_nil)           % Integer
      (lambda (float : Float)   -> sexp_nil)           % Float
      (lambda (lst : List Sexp) -> sexp_nil)) in       % List of Sexp

  % Get a name from a sexp
  % (name t) -> name
  % name -> name
  let get-name : Sexp -> Sexp;
      get-name sxp =
        sexp_dispatch_ (a := Sexp) sxp
          (lambda (op : Sexp) -> (lambda (lst : List Sexp) -> get-name op)) % Nodes
          (lambda (str : String)    -> symbol_ str)              % Symbol
          (lambda (str : String)    -> symbol_ str)              % String
          (lambda (int : Int)       -> symbol_ "error")          % Integer
          (lambda (float : Float)   -> symbol_ "error")          % Float
          (lambda (lst : List Sexp) -> symbol_ "error") in       % List of Sexp

  let lst = get-list expr in

  let name = head (a := Sexp) lst in
  let ctor = tail (a := Sexp) lst in

  let type-name = get-name name in

  % Create the inductive type definition
  let inductive = node_ (symbol_ "inductive_")
    (cons (a := Sexp) type-name ctor) in

  % Create a forward declaration in case the declaration is recursive
  let fdecl = make-ann type-name (symbol_ "Type") in
  let decl  = make-decl type-name inductive in

  % Add constructors
  let ctors =
   let for-each : List Sexp -> List Sexp -> List Sexp;
       for-each ctor acc = case ctor
        | cons hd tl => (
          let acc2 = cons (a := Sexp)  (make-cons (get-name hd) type-name) acc in
            for-each tl acc2)
        | nil => acc
      in for-each ctor (nil (a := Sexp)) in

  % return decls
     cons (a := Sexp) fdecl      % Forward declaration
    (cons (a := Sexp) decl       % inductive type declaration
                      ctors);    % constructor declarations


type_ = Macro_ type-impl;

% (type_ (_|_ (Nat t) zero (succ Nat)))
% (type_ (_|_ Nat zero (succ Nat)))
type Nat t
  | succ Nat
  | zero;
