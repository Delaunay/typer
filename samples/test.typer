%% Issues:
%% - syntax of "telescopes", especially the implicit and erasable args.
%%
%%   test {t} [dict : t -> t -> Bool] (x : t) (y : t) : Int = ...def...
%%
%% - syntax of Inductives.
%% 
%%   type List t
%%     | nil
%%     | cons [dict : Ord t] (head : t) (tail : List t)
%%
%% - syntax of funcalls
%%
%%   test {t = Int} [dict = int_eq] 3 4
%%
%% Notes:
%% - by analogy to the ->/=>/≡> distinctions, we could potentially use
%%   "a :/::/:::/ b", but that wouldn't work for the case where we don't
%%   want to specify the type explicitly.
%% - in telescopes (i.e. definitions), we could use the same syntax for
%%   implicit and erasable, and distinguish based on the use of the variable
%%   (e.g. in function definitions, see if it can be erasable), tho it's not
%%   clear how to do it for Inductive definitions.
%% - in funcalls, we could use the same syntax for implicit and erasable,
%%   and distinguish based on the type of the function being called.

a = 3;

Nat : Type
Nat = inductive_ (dummy_Nat) (zero) (succ Nat);
zero = datacons Nat zero;
succ = datacons Nat succ;
toZero = lambda z ->
             case z
             | zero => zero
             | succ x => toZero x;
x = 1;

id = lambda (α : Type) ≡> lambda x : α -> x;

%% This requires HM inference, not yet implemented.
%% identity = lambda x -> x;

%% This requires HM inference, not yet implemented.
%% x : a -> a;
%% x = lambda y ≡> lambda z -> z;

plus = lambda x y ->
           case x
           | zero => y
           | succ x => succ (plus x y);

List = inductive (dummy_List (α : Type))
                 (nil)
                 (cons α (List α));
nil = datacons List nil;
cons = datacons List cons;
length : (α : Type) ≡> List α -> Nat;
length = lambda α ≡> lambda (xs : List α) ->
                         case xs
                         | nil => zero
                         | cons x xs => succ (length xs);

%% This requires HM inference, not yet implemented.
%% length2 : List α -> Nat;
%% length2 = lambda xs ->
%%               case_ xs
%%                     (nil => zero)
%%                     (cons x xs => succ (length2 xs));

False = inductive (dummy_False);
Unit = inductive (dummy_Unit) (unit);
unit = datacons Unit unit;
Bool = inductive (dummy_Bool) (true) (false);
false = datacons Bool false;
true = datacons Bool true;
