% those are name aliases
symbol  = lambda (y : String)     -> (symbol_ y)  ;
string  = lambda (y : String)     -> (string_ y)  ;
integer = lambda (y : Int)        -> (integer_ y) ;
float   = lambda (y : Float)      -> (float_ y)   ;
block   = lambda (y : List Sexp)  -> (block_ y)   ;

% traverse nodes
node : Sexp -> List Sexp -> Sexp;
node = (lambda (op : Sexp) ->
    lambda (y : List Sexp)  ->
        case y
            | nil => node_ op nil
            | _ => node_ op (quote' y));

% tree traversal
quote' : List Sexp -> List Sexp;
quote' = lambda (x : List Sexp) ->
    let target = head Sexp x;
        tl = tail Sexp x;

        rhd = sexp_dispatch_ target
            node symbol string integer float block;

        rtl = case tl
            | nil => nil
            | _ => quote' tl;

        in (cons rhd rtl);


% quote definition
quote = Macro_ (lambda (x : List Sexp) -> head Sexp (quote' x));

% Should it return
% (node_ (symbol_ "_*_") (cons (symbol_ x) (cons (symbol_ x) nil)))

% OR
%        x * x  (Lexp, donc Call(_*_, [x x])

%main = quote (x * x);