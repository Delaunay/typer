% those are name aliases
symbol  = lambda (y : String)     -> (symbol_ y)  ;
string  = lambda (y : String)     -> (string_ y)  ;
integer = lambda (y : Int)        -> (integer_ y) ;
float   = lambda (y : Float)      -> (float_ y)   ;
block   = lambda (y : List Sexp)  -> (block_ y)   ;

quote' : List Sexp -> List Sexp;


%
%   f = (qquote (uquote x) * x) (node _*_ [(node_ unquote "x") "x"])
%
%   f = node_ "*" cons (x, cons (symbol_ "x") nil))
%
%
%     =>       x

% the expression needs to be handled
has-uquote : List Sexp -> Sexp;
has-uquote = lambda y ->
  head Sexp y; %node_ (symbol_ "node_") (quote' y);

% keep quoting the expression
hasnot-uquote : Sexp -> List Sexp -> List Sexp;
hasnot-uquote = lambda op ->
  lambda y ->
    case y
      | nil => node_ op nil
      | _ => node_ (quote' (cons op nil)) (quote' y);


% traverse nodes
node : Sexp -> List Sexp -> Sexp;
node = lambda (op : Sexp) ->
    lambda (y : List Sexp) ->
      case (sexp_eq op (symbol_ "uquote"))
        | True  => has-uquote y
        | False => hasnot-uquote op y;


% tree traversal
quote' = lambda (x : List Sexp) ->
    let target = head Sexp x;
        tl = tail Sexp x;

        rhd = sexp_dispatch_ target
            node symbol string integer float block;

        rtl = case tl
            | nil => nil
            | _ => quote' tl;

        in (cons rhd rtl);


% quote definition
qq = lambda (x : List Sexp) -> head Sexp (quote' x);
quote = Macro_ qq;

mn = quote (x * x);


