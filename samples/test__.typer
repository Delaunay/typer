


%a = lambda x ->
%    let a1 : Nat; a1 = 2; b1 : Nat; b1 = 3; in
%        a1 + b1 + x
%;

% main = (a 2)


Nat = inductive_ (dNat) (zero) (succ Nat);
        
zero = inductive-cons Nat zero; 
succ = inductive-cons Nat succ;

one = (succ zero);
two = (succ one);
three = (succ two);

tonum = lambda x -> case x 
    | (succ y) => (1 + (tonum y))
    | _ => 0
;
    
x = zero;
% main = zero; => zero(Nat[1])
% main = x; => succ(Nat[2])

main = (tonum one);



%================================ CALL TRACE ================================
%    size = 6
%----------------------------------------------------------------------------
%|+- Call: (tonum[1] zero[6])
%|:+- Var: zero[6]
%|:+- Lambda: lambda (x: unkwn) -> case x[0]: unkwn| succ y -> 1 + (tonum[4] y[0]); | zero -> 0; 
%|:|+- Case: case x[0]: unkwn| succ y -> 1 + (tonum[4] y[0]); | zero -> 0; 
%|:|:+- Var: x[0]
%|:|:+- Imm: 0
%============================================================================

%================================ CALL TRACE ================================
%    size = 11
%----------------------------------------------------------------------------
%|+- Call: (tonum[2] x[1])
%|:+- Var: x[1]
%|:+- Lambda: lambda (x: unkwn) -> case x[0]: unkwn| succ y -> 1 + (tonum[2] y[0]); | _ -> 0;
%|:|+- Case: case x[0]: unkwn| succ y -> 1 + (tonum[2] y[0]); | _ -> 0;
%|:|:+- Var: x[0]
%|:|:+- Var: zero[6]
%|:|:+- Call: 1 + (tonum[2] y[0])
%|:|:|+- Imm: 1
%|:|:|+- Call: (tonum[2] y[0])
%|:|:|:+- Var: y[0]
%|:|:|:+- Var: zero[6]
%============================================================================
