%*
%*      Typer Compiler
%*
%* ---------------------------------------------------------------------------
%*
%*      Copyright (C) 2011-2016  Free Software Foundation, Inc.
%*
%*   Author: Pierre Delaunay <pierre.delaunay@hec.ca>
%*   Keywords: languages, lisp, dependent types.
%*
%*   This file is part of Typer.
%*
%*   Typer is free software; you can redistribute it and/or modify it under the
%*   terms of the GNU General Public License as published by the Free Software
%*   Foundation, either version 3 of the License, or (at your option) any
%*   later version.
%*
%*   Typer is distributed in the hope that it will be useful, but WITHOUT ANY
%*   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
%*   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
%*   more details.
%*
%*   You should have received a copy of the GNU General Public License along
%*   with this program.  If not, see <http://www.gnu.org/licenses/>.
%*
%* ---------------------------------------------------------------------------
%*
%*      Description:
%*          Define builtin types and functions
%*
%* ---------------------------------------------------------------------------*)

% -----------------------------------------------------
%       Base Types
% -----------------------------------------------------

Type   = Built-in "Type";
Int    = Built-in "Int";
Float  = Built-in "Float";
String = Built-in "String";
Sexp   = Built-in "Sexp";

% Basic operators
_+_ : Int -> Int -> Int;
_+_ = Built-in "_+_";

_*_ : Int -> Int -> Int;
_*_  = Built-in "_*_";

% -----------------------------------------------------
%       List
% -----------------------------------------------------

List : Type -> Type;
List = inductive_ (dList (a : Type)) (nil) (cons a (List a));

nil = inductive-cons List nil;
cons = inductive-cons List cons;

length : (a : Type) => List a -> Int;
length = lambda a =>
  lambda xs ->
    case xs
      | nil => 0
      | cons hd tl => (1 + (length a tl));

head : (a : Type) => List a -> a;
head = lambda a =>
  lambda xs ->
    case xs
      | nil => nil
      | cons hd tl => hd;

tail : (a : Type) => List a -> List a;
tail = lambda a =>
  lambda xs ->
    case xs
      | nil => nil
      | cons hd tl => tl;

% -----------------------------------------------------
%       Macro
% -----------------------------------------------------

block_   : (List Sexp) -> Sexp;
block_   = Built-in "block_";

symbol_  : String      -> Sexp;
symbol_  = Built-in "symbol_";

string_  : String      -> Sexp;
string_  = Built-in "string_";

node_    : (List Sexp) -> Sexp;
node_    = Built-in "node_";

integer_ : Int         -> Sexp;
integer_ = Built-in "integer_";

float_   : Float       -> Sexp;
float_   = Built-in "float_";

Macro : Type;
Macro  = inductive_ (dMacro) (Macro_ ((List Sexp) -> Sexp));
Macro_ = inductive-cons Macro Macro_ ;

sexp_dispatch_ : Sexp -> (Sexp -> Sexp) -> (Sexp -> Sexp) -> (Sexp -> Sexp)
    -> (Sexp -> Sexp) -> (Sexp -> Sexp) -> (Sexp -> Sexp) -> (Sexp -> Sexp);
sexp_dispatch_ = Built-in "sexp_dispatch_";

















