%*
%*      Typer Compiler
%*
%* ---------------------------------------------------------------------------
%*
%*      Copyright (C) 2011-2016  Free Software Foundation, Inc.
%*
%*   Author: Pierre Delaunay <pierre.delaunay@hec.ca>
%*   Keywords: languages, lisp, dependent types.
%*
%*   This file is part of Typer.
%*
%*   Typer is free software; you can redistribute it and/or modify it under the
%*   terms of the GNU General Public License as published by the Free Software
%*   Foundation, either version 3 of the License, or (at your option) any
%*   later version.
%*
%*   Typer is distributed in the hope that it will be useful, but WITHOUT ANY
%*   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
%*   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
%*   more details.
%*
%*   You should have received a copy of the GNU General Public License along
%*   with this program.  If not, see <http://www.gnu.org/licenses/>.
%*
%* ---------------------------------------------------------------------------
%*
%*      Description:
%*          Define builtin types and functions
%*          This file MUST be correctly typed
%*
%* ---------------------------------------------------------------------------

% -----------------------------------------------------
%       Base Types
% -----------------------------------------------------

Int     = Built-in "Int";
Float   = Built-in "Float";
String  = Built-in "String";
Sexp    = Built-in "Sexp";

Unit    = Built-in "Unit";      % Nothing
Context = Built-in "Context";   % Lexp Context

% Basic operators
_+_ = Built-in "_+_" (Int -> Int -> Int);
_*_ = Built-in "_*_" (Int -> Int -> Int);


Bool = inductive_ (Boolean) (True) (False);
True = inductive-cons Bool True;
False = inductive-cons Bool False;

%Option : Type -> Type;
Option = inductive_ (Option (a : Type)) (None) (Some a);
Some = inductive-cons Option Some;
None = inductive-cons Option None;

string_eq = Built-in "string_eq" (String -> String -> Bool);
int_eq    = Built-in    "int_eq" (Int -> Int -> Bool);
sexp_eq   = Built-in   "sexp_eq" (Sexp -> Sexp -> Bool);

% -----------------------------------------------------
%       List
% -----------------------------------------------------

List : Type -> Type;
List = inductive_ (dList (a : Type)) (nil) (cons a (List a));

nil = inductive-cons List nil;
cons = inductive-cons List cons;

length : (a : Type) => List a -> Int;
length = lambda a =>
  lambda xs ->
    case xs
      | nil => 0
      | cons hd tl => (1 + (length(a := a) tl));

head : (a : Type) => List a -> a;
head = lambda a =>
  lambda xs ->
    case xs
      | nil => nil
      | cons hd tl => hd;

tail : (a : Type) => List a -> List a;
tail = lambda a =>
  lambda xs ->
    case xs
      | nil => nil
      | cons hd tl => tl;

% -----------------------------------------------------
%       Macro
% -----------------------------------------------------

block_   = Built-in "block_"   ((List Sexp) -> Sexp);
symbol_  = Built-in "symbol_"  (String      -> Sexp);
string_  = Built-in "string_"  (String      -> Sexp);
node_    = Built-in "node_"    (Sexp -> (List Sexp) -> Sexp);
integer_ = Built-in "integer_" (Int         -> Sexp);
float_   = Built-in "float_"   (Float       -> Sexp);

% Macro  : Type;
Macro  = inductive_ (dMacro) (Macro_ ((List Sexp) -> Sexp));
Macro_ = inductive-cons Macro Macro_ ;

sexp_dispatch_ = Built-in "sexp_dispatch_" (Sexp
    -> (Sexp -> List Sexp -> Sexp)
    -> (String -> Sexp)
    -> (String -> Sexp)
    -> (Int -> Sexp)
    -> (Float -> Sexp)
    -> (List Sexp -> Sexp)
        ->  Sexp);

% -----------------------------------------------------
%       Monads
% -----------------------------------------------------

IO = Built-in "IO" (Type -> Type);

% Builtin bind
bind = Built-in "bind" (
  (a : Type) ≡>
  (b : Type) ≡>
    IO a -> (a -> IO b) -> (IO b));

% return = Built-in "return" ((a : Type) ≡> a -> IO a);

% File monad

% define a dummy type that supposed to represent a file
FileHandle = Built-in "FileHandle";

% define operation on file handle
run-io = Built-in "run-io" (
  %% FIXME: runIO should have type IO Unit -> b -> b
  %% or IO a -> b -> b, which means "run the IO, throw away the result,
  %% and then return the second argument unchanged".  The "dummy" b argument
  %% is actually crucial to make sure the result of runIO is used, otherwise
  %% the whole call would look like a dead function call and could be
  %% optimized away!
  (a : Type) ≡>
  (b : Type) ≡>
    IO a -> (a -> IO b) -> (IO b) -> Unit);

open  = Built-in "open"  (String -> String -> IO FileHandle);
write = Built-in "write" (FileHandle -> String -> IO Unit);
read  = Built-in "read"  (FileHandle -> Int -> IO String);

% -----------------------------------------------------
%       Attributes
% -----------------------------------------------------

Attribute = Built-in "Attribute";
new-attribute = Built-in "new-attribute" (Macro);

add-attribute = Built-in "add-attribute" (Macro);
attribute = Macro_ add-attribute;

get-attribute = Built-in "get-attribute" Macro;
has-attribute = Built-in "has-attribute" (Macro);

% -----------------------------------------------------
%       Context Accessors
% -----------------------------------------------------

%% FIXME: These should be functions!
decltype = Built-in "decltype" Macro;
declexpr = Built-in "declexpr" Macro;



