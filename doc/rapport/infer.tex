\chapter{L'inférence de type}
    \section{Parser}

        \structpar{Fonctionnement général du parser}
            L'interprétation du code se fait de cette façon:

        \begin{center}
            code typer $\xrightarrow[]{prelexer}$ code \say{prélexé} $\xrightarrow[]{lexer}$ \sexp{} $\xrightarrow[]{}$ \pexp{} $\xrightarrow[]{}$ \lexp.\\
        \end{center}

        \structpar{Les \sexp{}}
            Les \texttt{S-Expressions} (\textit{Symbolic expressions}) sont une structure de données en forme d'arbre.
            Cette structure de données a été inventée et utilisée pour la première fois par le langage \textit{Lisp}.
            Les \sexp{} permettent de représenter un arbre de syntaxe abstrait c'est pourquoi elles ont été utilisées
            comme représentation interne du compilateur.

        \structpar{Les \pexp{}}
            Les \texttt{Proto Lambda-Expression} sont une représentation à mi-chemin entre les \sexp{} et les \lexp{}.
            Elles sont utilisées uniquement pour faciliter la transformation des \sexp{} en \lexp{}.

        \structpar{Les \lexp{}}
            Les \lexp{}\ref{fig:ocmllxp} sont des expressions représentant les \textit{Lambda-Expressions} du $\lambda{}-calcul$.
            Elles servent de représentation intermédiaire du code \typer{}.
            Les différentes opérations, comme la vérification de type, se fait sur les \lexp{}.

        \structpar{Détails}
            Lors de l'interprétation du code, il est tout d'abord \say{prélexé}.
            Durant cette phase, les commentaires sont supprimés, les litéraux (nombres et chaines de caractères)
            sont séparés du code et le code est séparé selon les parenthèses.

            Ensuite, le code \say{prélexé} passe par le lexer qui va transformer le code en \sexp{}.
            Les \sexp{} sont ensuite transformées en \pexp{}.
            Enfin, les \pexp{} sont transformés en \lexp{}. Durant cette phase, les informations de type vont être rajoutées aux \lexp{}.

        \structpar{L'inférence de type et l'unification}
            L'inférence de type se fait sur les \lexp{}. En effet ce sont les seules expressions
            à avoir une information sur leur type.

    \section{Unification}
        L'unification est moyen permettant de déterminer si deux expressions sont équivalentes.
        Dans le cas de l'inférence de type pour le compilateur \typer{},
        l'unification se fait sur les \lexp{}.
        Deux \lexp{} sont unifiables si elles sont équivalentes. Si les expressions $S$ et $T$
        sont unifiables alors on peut écrire (en \typer{}) $S = T$.

        Dans le cas du compilateur \typer{}, l'unification permet de vérifier qu'il n'y a pas
        d'erreur de typage.

    \subsection{Unification de premier ordre}

            \structpar{L'unification des \lexp}
                L'unification de premier ordre permet de déterminer si deux \lexp{} sont équivalentes, dans les cas simples.
                Cependant, toutes les informations nécessaires ne sont pas toujours disponibles lors de l'unification.
                L'algorithme d'unification renvoie une liste de contraintes et une liste d'associations entre une méta-variable et une \lexp{} quelconque.
                Le couple formé par ces deux listes est appelé le \textit{contexte d'unification}\ref{fig:ctxunif}.

            \structpar{Cas Évident}
                Si deux \lexp{} sont équivalentes, elles sont unifiables. Par exemple, deux nombres égaux seront transformés en deux \lexp{} équivalentes.
                Ces deux \lexp{} seront unifiables.
                Dans ce cas, l'algorithme d'unification renvoie le même \textit{contexte d'unification} qui lui a été donné en paramètre.

                Respectivement, deux \lexp{} peuvent être facilement identifiées comme non unifiables. Par exemple, les \lexp{} générées par deux nombres différents
                ne seront pas unifiables.
                Dans ce cas, l'algorithme d'unification renvoie une erreur. En effet, l'unification de deux \lexp{} non unifiables correspond,
                dans l'inférence de type, à une erreur de typage.

            \structpar{Cas qui renvoie une contrainte}
                Certains cas ne permettent pas de donner une réponse sur le résultat de l'unification. En effet, les informations disponibles
                ne sont pas suffisantes. C'est notamment le cas avec les variables et les fonctions.
                Dans ce cas, l'algorithme d'unification renvoie une contrainte indiquant que les deux \lexp{} doivent être unifiables.
                Plus tard dans l'exécution, cette contrainte sera validée, si le code est correct, ou invalidée, s'il y a une erreur de type.
                La liste des contraintes du \textit{contexte d'unification} est représentée sous la forme d'une liste de couples.
                Chaque couple représentant de \lexp{} qui doivent être unifiables pour que le typage soit correct.
                L'algorithme d'unification renvoie, dans le cas où il doit générer une contrainte, le \textit{contexte d'unification} passé en paramètre
                en rajoutant dans la liste des contraintes le couple formé par les deux \lexp{} passées en paramètre.

            \structpar{Méta-variables}
                Lorsque l'algorithme d'unification rencontre une méta-variable, il l'associe à l'autre \lexp{} passée en paramètre.
                Si la méta-variable est déjà associée à une \lexp{}, alors l'algorithme essaiera d'unifier la \lexp{} associée à la méta-variable
                et la \lexp{} passée en paramètre.
                Si la méta-variable n'est pas associée à une \lexp{}, l'algorithme renvoie le \textit{contexte d'unification} auquel est rajoutée une
                association entre la \lexp{} et la méta-variable. Sinon, l'algorithme renvoie le résultat de l'unification de la \lexp{} passée en paramètre
                avec la \lexp{} associée à la méta-variable.

            \structpar{Résultat de l'algorithme}
                Le résultat de l'alogrithme permet donc de déterminer quel cas il à rencontré:
                \begin{itemize}
                    \item Si la liste d'association est la même en entrée et en sortie alors les deux \lexp{} passées en paramètre sont unifiables.
                    \item Si l'unification ne renvoie rien les \lexp{} passée en paramètre ne sont pas unifiables.
                    \item Si la liste des contraintes renvoyé par l'unification contient une contrainte de plus alors l'unification ne possédait pas assez d'information pour renvoyer un resultat.
                    \item Si la liste d'association renvoyé par l'unification contient une association de plus alors une des deux \lexp{} passée en paramètre était une méta-variable.
                \end{itemize}

            \structpar{Ce qu'il manque}
                L'unification de premier ordre ne tient pas en compte des ajouts et suppressions de variables. C'est pourquoi cette forme d'unification ne suffit
                pas pour l'inférence de type requise par \typer{}.

        \subsection{Unification des \hop{}}
            \structpar{\hop{}}
                L'unification de premier ordre ne suffit pas pour l'inférence de type requise par \typer{}.
                En effet, l'unification de premier ordre ne tient pas compte des modifications des index de \textit{de Bruijn}.
                L'unification de \typer{} utilise un sous-ensemble de l'unification des \hop{}
                L'unification des \hop{} est un sous-ensemble décidable de l'unification d'ordre supérieur.

            \structpar{Les index de \textit{de Bruijn}}
                Les index de \textit{de Bruijn} sont une notation inventée par Nicolaas Govert de Bruijn qui sert à représenter les
                termes du $\lambda{}-calcul$. Cette notation utilise des index comme identificateur de variables (dans le code). L'index le plus grand
                correspond à la première variable instanciée (et toujours définie).

                Les index de \textit{de Bruijn} facilitent la comparaison de variable par rapport à l'utilisation de nom de variable comme identifiant.
                En effet, deux variables peuvent avoir le même nom de variable tout en étant différentes. Avec l'utilisation des index de \textit{de Bruijn},
                ces deux variables auront des index différents puisqu'elles sont différentes.
                Cependant, le décalage des index lié à l'ajout et la suppression de variables peut causer des erreurs lors de la comparaison d'une même
                variable dans des contextes différents.

            \structpar{La substitution des index de \textit{de Bruijn}}
                Pour remédier au problème de l'ajout et de la suppression de variables avec les index de \textit{de Bruijn}, on associe au contexte des
                variables une substitution. Cette substitution, une fois appliquée à un index, l'augmente ou le réduit.
                Ceci permet de modifier les index en fonction du contexte et pouvoir comparer des variables dans différents contextes.

            \structpar{L'unification avec les index de \textit{de Bruijn}}
                Pour prendre en compte les différences de contexte lors de l'unification, il faut intégrer
                les substitutions d'index de \textit{de Bruijn} dans l'unification.
                Pour cela, on associe à une meta-variable l'inverse de la substitution en cours. De cette
                façon, les \texttt{Metavar} (représentation des méta-variables dans le compilateur) ne représentent plus
                des méta-variables mais l'application d'une substitution à une méta-variable.
                Cette modification permet de prendre en compte le contexte dans lequel la méta-variable a été créée
                et ainsi de pouvoir appliquer les substitutions lors de l'unification de variables dans des contextes différents.

